\documentclass{article}
\input{common}

\begin{document}

\section*{Лекция 6. Логарифмический алгоритм для \textbf{UPATH}}
\addcontentsline{toc}{section}{Лекция 6. Логарифмический алгоритм для
\textbf{UPATH}}
\resetcntrs

\section{Общая идея}

Первый шаг~--- доказать, что диаметр экспандера
есть~$O(\log_{\frac{1}{\lambda}})$ при константном~$\lambda$.

Если степень экспандера константна, то все пути длины $O(\log N)$ можно
перебрать за полиномиальное время на логарифмической памяти.

Следующая идея: с~помощью зигзаг-произведения превращать граф в~экспандер,
сохраняя связность. В~полученном экспандере проверим наличие пути перебором.

\section{Диаметр экспандера}

\begin{claim}
	Если $\pi$~--- распределение верятностей, $M$~--- матрица случайного
	блуждания, $u = (\frac{1}{N}, \ldots, \frac{1}{N})$, то $\Vert \pi M^l - u
	\Vert_2 \le \lambda^l$.
\end{claim}
\begin{proof}
	$\pi = \pi^\Vert + \pi^\bot = u + \pi^\bot$. $\pi M^l = u + \pi^\bot M^l
	\Rightarrow \Vert \pi M^l - u \Vert = \Vert \pi^\bot M^l \Vert \le \lambda^l
	\Vert \pi \Vert \le \lambda^l \Vert \pi \Vert_1 = \lambda^l$.
\end{proof}

\section{Приведение графа к~экспандеру}

\begin{claim}
	Можно считать, что данный граф 3-регулярный.
\end{claim}
\begin{proof}
	Каждую точку, у~которой меньше трёх соседей, дополним кратными петлями. Каждую
	точку, из которой выходит больше трёх ребер преобразуем в~цикл длины равной её
	степени с~торчащими рёбрами куда надо.
\end{proof}

Алгоритм будет следующий:
\begin{itemize}
	\item Выберем граф~$H$ с~параметрами~$(D^4, D, \frac{3}{4})$, $D$~---
		константа.
	\item $D^2$-регуляризуем граф, притом сделаем его не двудольным (петлей,
		например).
	\item $k = 1, \ldots, l = O(\log N)$, $G_k = G_{k-1}^2 \textcircled{z} H$,
		$s_k, t_k$~--- произвольные вершины из облаков~$s_{k-1}, t_{k-1}$.
	\item Проверяем $s$~---~$t$ связность в~экспандере перебором.
\end{itemize}

\begin{claim}
	Алгоритм корректен.
\end{claim}
\begin{proof}
	Граф недвудольный и~связный, значит $\lambda$ отделено от 1, и~после шага
	алгоритма все так и~останется. Это рассуждение можно применить для каждой
	связной компоненты исходного графа, значит компоненты сохраняются.

	Пусть~$C_k$~--- компонента связности $G_k$, содержащая $s_k$. $\gamma(C_0) =
	\frac{1}{poly(N)}$. $\gamma(C_{k-1}^2) \ge 2\gamma(C_{k-1}) -
	\gamma^2(C_{k-1})$. Тогда:
	$$\gamma(C_{k-1}^2 \textcircled{z} H) \ge
	\frac{2 \cdot 9}{16} \gamma(C_{k-1})(1 - \frac{\gamma(C_{k-1})}{2}) \ge
	\min\left\{\frac{35}{32}\gamma(C_{k-1}),\frac{1}{18}\right\}$$.

	Для вычисления соседа в~$G_k$ нужен 1 переход в~$G_{k-1}^2$
	и~2~перехода~в~$H$. Переходы в~$H$ памяти не требуют, то есть в~итоге получаем
	два перехода в~$G_{k-1}$.

	Логарифмическая память не зависит от модели вычислений, но доказать, что на
	каждой итерации добавляется константная память можно только в~конкретной
	модели. Мы рассматрим такую модель: лента с~исходным графом~$G$, лента с~$u,
	i$ + дополнительная информация, рабочая лента. При запросе мы меняем~$(u, i)$
	на~$(v, j)$, не меняя дополнительной информации. В~такой модели нетрудно
	придумать, как вычислять квадрат и~нормально так попотеть. По сути,
	утверждается, что рекурсия здесь почти хвостовая.
\end{proof}

\end{document}
