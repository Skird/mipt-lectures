\documentclass{article}
\input{common}

\begin{document}

\section*{Лекция 4. Псевдослучайные функции}
\addcontentsline{toc}{section}{Лекция 4. Псевдослучайные функции}
\resetcntrs

\section{Псевдолучайные функции с~неадаптивным отличителем}

\begin{definition}
	Семейство функций $\{f_s^n\}: f_s^n: \{0, 1\}^n \rightarrow \{0, 1\}^n, s \in
	\{0, 1\}^{p(n)}$ называется псевдослучайным, если:
	\begin{itemize}
		\item Существует полиномиальный алгоритм, который по~$s$ и~$x$
			вычисляет~$f_s^n(x)$.
		\item Надёжность против неадаптивных отличителей:\\
			$\forall q(\cdot)\ \forall\{D_n\} \forall\{x_1, \ldots, x_{q(n)}\}\,
			\forall w(\cdot)\ \exists N: \forall n > N \rightarrow\\
			|P_s(D_n(x_1, \ldots, x_{q(n)}, f_s(x_1), \ldots, f_s(x_{q(n)})) = 1) -\\
			P_g(D_n(x_1, \ldots, x_{q(n)}, g(x_1), \ldots, g(x_{q(n)})) = 1)| <
			\frac{1}{w(n)}$
	\end{itemize}
\end{definition}

\begin{theorem}
	Если существует генератор псевдослучайных чисел из $\{0, 1\}^n$ в~$\{0,
	1\}^{2n}$, то существует и~семейство псевдослучайных функций.
\end{theorem}
\begin{proof}
	Конструкция такова: для некотрого~$x$ длины~$n$ делаем следующее:
	\begin{itemize}
		\item Считаем $G(s) = s_0 s_1$, если 1й бит~$x$ равен~1, то берем $s_1$,
			иначе $s_0$.
		\item Считаем $G(s_{x_1}) = s_{x_1 0}s_{x_1 1}$, выбираем одну из половин
			в~зависимости от~$x_2$.
		\item Продолжаем аналогично.
	\end{itemize}

	Доказательство индукцией по дереву: нарисуем бинарное дерево, которое является
	частью полного бинарного, содержащей $x_1, \ldots, x_{q(n)}$. На каждом
	следующем уровне мы имеем $s_{a_1}, \ldots, s_{a_r}$, однако в~силу
	псевдослучайности мы можем вычислительно неотличимо заменить их на
	действительно случайные значения. Поскольку размер дерева полиномиален, то мы
	использовали вычислительную неотличимость полиномиально много раз, что делать
	можно.

	Более формально: если $G(y) = G_0(y)G_1(y)$, то можно записать $f_s(x) =
	G_{x_n}(G_{x_{n-1}}(\ldots G{x_1}(s)\ldots))$.\\
	$h_{i,t}(x)=G_{x_n}(G_{x_{n-1}}(\ldots G{x_{i+1}}(t_{x_1\ldots x_i})\ldots))$,
	$|t|=2^{n+i}$.\\
	$h_{0,t}(x) = f_t(x)$, $h_{n,t}(x)$~--- случайная функция.
	Цепочка эквивалентностей приводит к~тому, что они вычислительно неотличимы.
\end{proof}

\section{Адаптивные отличители}

\begin{example}
	Пример, когда адапитивный отличитель сильнее неадаптивного: пусть есть $f$,
	такая что:\\
	$f(0 \ldots 0) = v$~--- случайное, $f(v) = 0 \ldots 0$, все остальные слова
	случайны.

	Адаптивный отличитель легко справится с~такой задачей, а~для неадаптивного
	отличителя вероятность найти нужное значение~$v$ очень мала.
\end{example}

Мы воспользуемся тем, что адаптивные алгоритмы~--- это то же самое, что
алгоритмы с~подсказкой и~доступом к~оракулу-функции. Алгоритм получает на
вход~$1^n$ и~подсказку~$a_n$ длины $poly(n)$.

$A^g(1^n, a_n)$~--- это результат работы такого алгоритма с~функцией~$g$
в~качестве оракула.

\begin{definition}
Систему псевдослучайных функций будем называть усточивой относительно
	адаптивного отличителя, если $\forall A\text{~--- отличителя}\,\forall
	q(\cdot)\, \exists N: \forall n > N \rightarrow
	|P_s(A^{f_s}(1^n, a_n) = 1) - P_g(A^g(1^n, a_n) = 1)| < \frac{1}{q(n)}$.
\end{definition}

\begin{claim}
	Построенная система функций устойчива относительно адаптивного отличителя.
\end{claim}
\begin{proof}
	Доказательство в~целом такое же, только одного общего дерева нет, оно стоится
	по ходу алгоритма. Однако в~ходе рассуждений ничего особо не меняется.
\end{proof}

Вариации с~параметрами могут быть следующие:
\begin{itemize}
	\item Уменьшение длины - легко, если уменьшить длину выхода, ничего не
		нарушится.
	\item $f_s: \{0, 1\}^\ast \rightarrow \{0, 1\}^{r(n)}, s \in \{0, 1\}^{p(n)}$.
		Используется генератор $G: \{0, 1\}^{p(n)} \rightarrow
		\{0, 1\}^{2p(n)+r(n)}$, $G(s) = \underbrace{G_0(s)}_{p(n)}
		\underbrace{G_1(s)}_{p(n)} \underbrace{G_2(s)}_{r(n)}$, а~функции
		вычисляются так: $f_s(x) = G_2(G_{x_k}(G_{x_{k-1}}(\ldots)))$.
\end{itemize}

\end{document}
