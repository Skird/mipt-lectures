\documentclass{article}
\input{common}

\begin{document}

\section*{Лекция 2. Слабо и~сильно односторонние функции}
\addcontentsline{toc}{section}{Лекция 2. Слабо и~сильно односторонние функции}
\resetcntrs

\section{Построение сильно односторонней функции из слабой}

Напоминание:

\begin{definition}
	Слабо односторонняя функция $f(x)$~--- это такая, что $\exists p(x) \ge 0
	\forall \{C_n\}_{n=1}^{\infty} \exists N \forall n \ge N \rightarrow
	P(f(C_n(f(n))) = f(x)) < 1 - \frac{1}{p(n)}$, где $C_n$~--- семейство схем
	полиномиального размера, а~$f(x)$ вычислима за полиномиальное время.
\end{definition}
\begin{definition}
	Сильно односторонняя функция $f(x)$~--- это такая, что $\forall p(x) \ge 0
	\forall \{C_n\}_{n=1}^{\infty} \exists N \forall n \ge N \rightarrow
	P(f(C_n(f(n))) = f(x)) < \frac{1}{p(n)}$.
\end{definition}

\begin{theorem}
	Если существует слабо односторонняя функция, то существует и~сильно
	односторонняя.
\end{theorem}
\begin{proof}
	Рассмотрим функцию~$F(x_1, \ldots, x_N) = (f(x_1), \ldots, f(x_N))$. Ясно, что
	такая функция защищена от наивных обратителей, которые пытаются обратить
	каждую компоненту по отдельности. Однако, неясно, почему не существует более
	сложного и~более эффективного обратителя.

	Поэтому мы возьмем гипотетический обратитель $R_F$ для $F$ в~обратитель $R_f$
	для $f$. Обратитель $R_f(y) = R_F(y, f(x_2), \ldots, f(x_N))\mid_1$ может не
	преуспеть, так как при фиксированной первой компоненте вероятность успеха
	может быть мала. Однако, мы можем запускать обратитель $R_F$ много раз,
	поэтому сделаем так:

	\begin{minted}[tabsize=4]{cpp}
		for (int i = 0; i < n; ++i) {
			for (int j = 0; j < K; ++j) {
				x_1, ..., x_n = gen_random();          // except i
				X = R_F(f(x_1), ..., y, ... , f(x_n)); // except i
				if (f(X) == y) {
					return X;
				}
			}
		}
	\end{minted}

	Для всех $i = 1, \ldots, n$~$K$ раз выберем случайные $x_1, \ldots, x_{i-1},
	x_{i+1}, \ldots, x_n$, и~запустим $R_F(f(x_1), \ldots, f(x_{i-1}), y,
	f(x_{i+1}), \ldots, f(x_n))$ и~выберем $i$-ю компоненту~$x$. Если $f(x) = y$,
	вернем $x$.

	Пусть $\rho_i(x) = P \left\{ f(R_F(\ldots)) = f(x) \right\}$, $\rho_{\max}(x) =
	\underset{i=1,\ldots,N}{\max} \rho_i(x)$. $x$ бывает двух видов: такой, что
	$\rho_{\max}(x) \ge \eps$ и~такой, что $\rho_{\max} < \eps$, доля последних
	равна $\delta$.

	Вероятность неудачи в~таком случае $R_f \le \delta + (1 -
	\eps)^k$. Если $F$~--- не сильно одностороняя, то вероятность успеха $R_F >
	\frac{1}{q(n)}$.

	Для $(x_1, \ldots, x_n)$ вероятность, что все $x_i$ хорошие $\le (1 -
	\delta)^N$, а~если хотя бы один $x$ плохой, то условная вероятность обращения
	$R_F < \eps$.

	Тогда вероятность успеха~$\frac{1}{q(n)} < R_F < \eps + (1 - \delta)^N$. При
	$\eps = \frac{1}{2q(n)}$ получается, что $(1 - \delta)^N > \frac{1}{2q(n)}$.
	При $N = n p(n) \Rightarrow \delta < \frac{1}{2p(n)}$. За счёт выбора $K$
	можем сделать $K = n q(n)$ и~тогда $(1 - \eps)^K < \frac{1}{2p(n)}$. В~итоге
	$\delta + (1 - \eps)^K < \frac{1}{p(n)}$, что означает, что $f$ не слабо
	односторонняя.
\end{proof}

\section{Примеры <<односторонних>> функций}

Функция Рабина: $(x, y) \mapsto (x^2 \mod y, y)$. $y = p \cdot q, 0 \le x < y$,
притом $p, q$~--- простые числа вида $4k + 3$.

Функция \text{RSA}: $(x, y, z) \mapsto (x^z \mod y, y, z)$.

$P\{ f(R_n(f(x))) = f(x) \}$ определяется по всем $x \in D_n$, притом требование
к~области $D_n$ таково, что нужно уметь порождать случайные элементы $D_n$, то
есть существует полиномиальный вероятностный алгоритм, порождающий случайную
величину, статистически близкую к~равномерной на $D_n$ (расстояние между любыми
двумя событиями меньше любого обратного полинома).

Можно отметить, что у~функции Рабина, например, есть так называемый <<секрет>>
(разложение $y = p \cdot q$), благодаря которому можно расшифровать сообщение.
Более формально определим

\begin{definition}
	Семейство односторонних функций с~секретом $\{ f_\alpha \}_{\alpha \in A}$:
	$f_\alpha: D_\alpha \rightarrow R_\alpha$ это такие функции, что существуют 4
	алгоритма:
	\begin{itemize}
		\item Генератор: $1^n \rightarrow (\alpha, \tau)$, генерирует ключ и~секрет.
		\item Сэмплер: $\alpha \mapsto $ случайный элемент $D_\alpha$ (с~точностью
			до статистической близости).
		\item Вычислитель: $(\alpha, x) \mapsto f_\alpha(x)$.
		\item Обратитель: $(\alpha, \tau, y) \mapsto f_\alpha^{-1}(y)$.
	\end{itemize}
	Притом $(\alpha, y) \mapsto f_\alpha^{-1}(y)$ труднообратимо в~обычном смысле.
\end{definition}

Улучшенная односторонняя перестановка с~секретом: $y$ выбирается как случайный
элемент $D_\alpha$, а~обратитель помимо $\alpha$ и~$y$ получает случайные биты,
использованные при порождении $y$ (при этом они все равно ему не помогают).

\section{Генераторы псевдослучайных чисел}

\begin{definition}
	$G$~--- генератор псевдослучайных чисел, если
	\begin{itemize}
		\item $G: \{0, 1\}^n \rightarrow \{0, 1\}^{p(n)}$.
		\item $G$ вычислима за полином.
		\item $\forall \{D_n\}_{n=1}^{\infty} \forall q(\cdot) \rightarrow
			\exists N: \forall n > N \rightarrow \left| P_{x \sim U_n}(D_n(G(x)) = 1)
			- P_{y \sim U_{p(n)}}(D_n(y) = 1) \right| < \frac{1}{q(n)}$.
	\end{itemize}
\end{definition}

Ясно, что генератор должен быть односторонней функцией, так как иначе обратитель
мог бы отличить вывод генератора от случайного вывода.

\begin{theorem}
	Если существует односторонняя функция, то существует и~генератор.
\end{theorem}

Мы докажем ослабленную версию этой теоремы:

\begin{theorem}
	Если существует односторонняя перестановка, то существует и~генератор.
\end{theorem}

\begin{definition}
	Трудный бит. Схематически: $x \mapsto f(x), x \mapsto b(x)$ вычисляются
	легко, $|b(x)| = 1$. При этом по $f(x)$ сложно вычислить $b(x)$:

	$\forall q(\cdot) \forall\{ P_n \}_{n=1}{\infty} \exists N \forall n > N
	|P(P_n(f(x)) = b(x)) - \frac{1}{2}| < \frac{1}{q(n)}$.
\end{definition}

Схема доказательства теоремы такая:
\begin{itemize}
	\item Односторонняя перестановка $f \mapsto$ односторонняя перестановка
		с~трудным битом: $g(x, y) = (f(x), y), b(x, y) = x \odot y =
		\bigoplus\limits_{i=1}^n x_i y_i$.
	\item Генератор $n \rightarrow n + 1$: $G(x) = g(x) b(x)$.
	\item Генератор $n \rightarrow p(n)$: $g(g(x))b(g(x))b(x),
		g(g(g(x)))b(g(g(x)))b(g(x))b(x), \ldots$.
\end{itemize}

\end{document}
