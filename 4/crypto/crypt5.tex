\documentclass{article}
\input{common}

\begin{document}

\section*{Лекция 5. Шифрование с~открытым и~закрытым ключoм}
\addcontentsline{toc}{section}{Лекция 5. Шифрование с~открытым и~закрытым
ключoм}
\resetcntrs

\section{Принципиальная схема шифрования}

Пока что рассмотрим только задачи одноразового шифрования.

Шифрование с~закрытым ключом: есть $Encoder(m, d)$, который передает сообщение
$c$ полиномиальной длины~$Decoder(d, c) \rightarrow m$. Нужно чтобы перехватчик
$A(c)$ не мог восстановить~$m$.

Шифрование с~открытым ключом: $Encoder(m, e)$ передает $c$ программе $Decoder(c,
d) \rightarrow m$. Ключи $e, d$ у~них разные, и~перехватичик~$A(c, d)$ может
пользоваться одним из них.

\section{Шифрование с~закрытым ключом}

Более формально, есть полиномиальные алгоритимы, $G$~--- генератор ключей,
$E$~--- шифратор, $D$~--- дешифратор с~понятными условиями:
\begin{itemize}
	\item Корректность~--- $P(D(d, E(d,m)) = m) = 1$.
	\item Надёжность~--- $E(d, m_1) \sim E(d, m_2)$ (вычислительно не отличимы)
		для $m_1 \ne m_2$ или, что тоже самое $E(d, m_1) \sim E(d, 0\ldots0)$.
\end{itemize}

Для закрытого ключа есть идеальная, но довольно бесполезная процедура: передать
$m \oplus d$, где~$d$~--- случайная строка. Есть две проблемы: ключ по длине
равен сообщению (если мы можем обменяться такими ключами, то почему не можем
обменяться сообщениями?), но даже если предположить, что мы заранее договорились
о~закрытом ключе, то остается проблема того, что шифр одноразовый: если известно
$m_1 \oplus d$ и~$m_2 \oplus d$, то можно узнать $m_1 \oplus m_2$, что может
быть полезной информацией.

\begin{theorem}
	Если существует генератор псевдослучайных чисел, то существует и~схема
	шифрования с~закрытым ключом для сообщений полиномиальной длины.
\end{theorem}
\begin{proof}
	Если параметр безопасности равен длине ключа, то схема описана выше.

	Вторая идея состоит в~том, чтобы шифровать <<раздутым>> ключом $c = m \oplus
	G(d)$. Корректность очевидна, надёжность следует из того, что $G(d) \sim r$,
	где $r$~--- случайная строка.
\end{proof}

Для многоразовой схемы нужно немного исправить условия:
\begin{itemize}
	\item Корректность~--- $P(D(d, E(d,m)) = m) = 1$.
	\item $\forall m_1, \ldots, m_k, m_1', \ldots, m_k' \rightarrow (E(d, m_1),
		\ldots, E(d, m_k)) \sim (E(d, m_1'), \ldots, E(d, m_k'))$.
\end{itemize}

\begin{theorem}
	Если существует семейство псевдослучайных функций, то существует схема
	многоразового шифрования с~закрытым ключом.
\end{theorem}
\begin{proof}
	Закрытый ключ~$d$~--- индекс случайной функции из семейства.

	$E$ выбирает случайный аргумент~$z$ и~посылает $c = (m \oplus f_d(z), z)$,
	$D(d, x, z) = x \oplus f_d(z)$. Корректность схемы очевидна.

	Надёжность: с~большой вероятностью все~$z_i$ различны. Тогда значения
	$f_d(z_1), \ldots, f_d(z_k)$ вычислительно неотличимы от~$r_1, \ldots, r_k$
	и~всё хорошо.
\end{proof}

\section{Шифрование с~открытым ключом}

Схема шифрования с~открытым ключом подразумевает, что есть полиномиальные
алгоритимы, $K$~--- генератор ключей, $E$~--- шифратор, $D$~--- дешифратор
со следующими условиями:
\begin{itemize}
	\item Корректность~--- $P(D(d, E(e,m)) = m) = 1$.
	\item Надёжность~--- $(E(e, m_1), e) \sim (E(e, m_2), e)$ для одноразовой
		схемы и~аналогиченое условие для многих перехваченных сообщений.
\end{itemize}

\begin{definition}
	Проверяемая односторонняя перестановка с~секретом~--- некоторое семейство
	перестановок (на разных областях определения), для которой:
	\begin{itemize}
		\item $\exists G$~--- генератор $(\alpha, \tau)$.
		\item $\exists f_\alpha: D_\alpha \leftrightarrow D_\alpha$.
		\item $\exists S$~--- сэмплер для почти равномерного распределения на
			$D_\alpha$.
		\item $\exists$Forwarder $F: (\alpha, x \in D_\alpha) \mapsto f_\alpha(x)$.
		\item $\exists$Backwarder $B: (\alpha, \tau, y \in D_\alpha) \mapsto
			f_\alpha^{-1}(y)$.
		\item Любой обратитель обращает $(\alpha, y) \mapsto
			f_\alpha^{-1}(y)$ с~вероятностью $\approx 0$.
	\end{itemize}
\end{definition}

\begin{theorem}
	$\exists$ односторонняя перестановка $\Rightarrow$ односторонняя перестановка
	с~секретом и~трудным битом ($h_\alpha(x)$, такой что по $f_\alpha(x)$
	и~$\alpha$ трудно восстановить $h_\alpha(x): (f_\alpha(x), \alpha,
	h_\alpha(x)) \sim (f_\alpha(x), \alpha b)$, $b$~--- случайный).
\end{theorem}
\begin{proof}
	Аналогично теореме в~предыдущих лекциях.
\end{proof}

Шифрование одного бита: $m \mapsto (m \oplus h_\alpha(x), f_\alpha(x))$, $x
\in_R D_\alpha$. Декодер, зная секрет $\tau$, восстановит $x, h_\alpha(x)$
и~расшифрует с~вероятностью~1.

Надёжность: $(\alpha, f_\alpha(x), h_\alpha(x) \oplus m) \sim (\alpha,
f_\alpha(x), b \oplus m) \sim (\alpha, f_\alpha(x), b)$ вне зависимости от $m$.

Много бит можно шифровать, генерируя каждый раз новый случайный~$x$. Таким
образом, обобщаем в~теорему:

\begin{theorem}
	Если существует односторонняя перестановка с~секретом, то существует схема
	шифрования с~открытым ключом.
\end{theorem}

\section{Бросание монетки по телефону}

Алиса и~Боб разводятся и~делят машину. Неоходимо получить общий случайный бит
в~условиях полного недоверия. $A$ и~$B$ представляют собой два рандомизированных
полиномиальных алгоритма с~независимыми случайными битами. Они общаются
протоколу и~после завершения выдают по одному биту~$\sigma, \tau$.

Нужно, чтобы оказалось так, чтобы~$\sigma = \tau, P(\sigma = 0) \approx
\frac{1}{2}$. Для этого есть полиномиальный алгоритм~$J$, который получает
протокол и~возвращает~$A, B, \bot_A, \bot_B$~--- либо сторону-победителя, либо
сторону, которая первая нарушила протокол.

Требуемые свойства:
\begin{itemize}
	\item Если обе стороны используют предписанные алгоритмы, то $P(J = A) = P(J =
		B) = \frac{1}{2}$.
	\item Если $A$ использует предписанный алгоритм, то $P(\bot_A) = 0$.
	\item Если $B$ использует предписанный алгоритм, то $P(\bot_B) = 0$.
	\item $\forall B^\ast \forall p(\cdot) \exists N: \forall n > N \rightarrow
		P(J \in \{A, \bot_B\}) \ge \frac{1}{2} - \frac{1}{p(n)}$, аналогично
		для~Боба.
\end{itemize}

Если бы можно было обмениваться сообщениями одновременно, то можно было бы
каждому послать случайный бит и~в~качестве результата взять их $\oplus$. Однако,
одновременных сообщений не предусмотрено, поэтому используется привязка к~биту
(bit commitment): $A$~--- посылает привязку $c$ к~$a \in \{0, 1\}$, $B$ посылает
случайный бит. Потом $A$ посылает ключ к~привязке и~все~вскрывается.

\end{document}
